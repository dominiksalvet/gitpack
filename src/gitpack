#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019-2020 Dominik Salvet
# https://github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# This is GitPack, a simple Git-based package manager. It is particularly useful
# for installing scripts across various platforms. This script is all you need
# to have GitPack running. All arguments are processed as GitPack help explains.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# MAIN FUNCTION
#-------------------------------------------------------------------------------

# $@ - GitPack arguments
main() {
    check_commands &&
    init_constants &&
    init_strings &&
    init_config &&
    init_env_vars &&
    init_opts &&
    process_args "$@"
}

check_commands() {
    if ! command -v git > /dev/null; then
        echo 'E1: missing git command' >&2; return 1
    fi
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------

init_constants() {
    readonly VERSION=0.7.0 # current GitPack version
}

init_strings() {
    readonly HELP_MESSAGE='USAGE:    gitpack [OPTION...] ACTION URL[=VERSION]...
          gitpack [OPTION...] COMMAND

ACTION:   install    install/update package
          uninstall  uninstall package
          status     get package status

COMMAND:  list   list installed packages
          clean  clean cache
          paths  show file paths
          help   show help
          about  show information

OPTION:   -h  short hash mode
          -H  long hash mode'

    readonly ABOUT_MESSAGE="GitPack $VERSION
Simple Git-based package manager.

Copyright 2019-2020 Dominik Salvet
https://github.com/dominiksalvet/gitpack"
}

init_config() {
    readonly BAD_URL_REGEX='(^$| |(^|/)\.\.?($|/))' # ERE regex

    # map remote references to local ones
    readonly ORIGIN_HEAD=refs/remotes/origin/HEAD # remote HEAD reference path
    readonly HEAD_REFSPEC=+HEAD:"$ORIGIN_HEAD" # default remote branch
    readonly TAGS_REFSPEC='+refs/tags/*:refs/tags/*' # versions
    readonly HEADS_REFSPEC='+refs/heads/*:refs/heads/*' # branches
}

init_env_vars() {
    export DIAG_PREFIX= # prefix for diagnostic messages (exported to scripts)
}

init_opts() {
    # global variables
    hash_mode= # short, long
}

#-------------------------------------------------------------------------------
# ARGUMENT PROCESSING
#-------------------------------------------------------------------------------

# $@ - GitPack arguments
process_args() {
    process_opts "$@" &&
    shift "$((OPTIND - 1))" && # shift to an actual subcommand

    case "$1" in
        install | uninstall | status)
            process_action_args "$@" ;;
        list | clean | paths)
            process_command_args "$@" ;;
        help) echo "$HELP_MESSAGE" ;;
        about) echo "$ABOUT_MESSAGE" ;;
        '') echoh 'E2: no subcommand provided'; return 1 ;;
        *) echoh "E3: invalid subcommand $1"; return 1 ;;
    esac
}

# $@ - GitPack options
process_opts() {
    while getopts :hH _opt; do
        case "$_opt" in
            h) hash_mode=short ;;
            H) hash_mode=long ;;
            ?) echoh "E13: invalid option -$OPTARG"; return 1 ;;
        esac || return
    done
}

# $1 - action
# $@ - action arguments
process_action_args() (
    init_runtime &&
    action="$1" &&
    shift && # shift to action arguments

    if [ "$#" -eq 0 ]; then
        echoh 'E4: no URL provided'; return 1
    fi &&

    for url in "$@"; do
        perform_action "$action" "$url" || return
    done
)

# $1 - command
# $@ - command arguments
process_command_args() (
    init_runtime &&
    case "$1" in # other arguments are ignored
        list) run_list ;;
        clean) run_clean ;;
        paths) run_paths ;;
    esac
)

# $@ - echo arguments
echoh() {
    echo "$@" >&2 &&
    echo "try 'gitpack help' for more information" >&2 # print also a hint
}

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------

init_runtime() {
    init_runtime_constants &&
    init_paths &&
    init_db &&
    init_index
}

init_runtime_constants() {
    _user_id="$(id -u)" &&
    if [ "$_user_id" -eq 0 ]; then
        readonly ACCESS=global
    else
        readonly ACCESS=local
    fi &&

    _system_name="$(uname)" &&
    readonly SYSTEM="$_system_name"
}

init_paths() {
    if [ "$ACCESS" = global ]; then # respect FHS
        readonly CACHE_DIR=/var/cache/gitpack
        readonly STATE_DIR=/var/lib/gitpack
    else # respect XDG
        readonly CACHE_DIR="$HOME"/.cache/gitpack
        readonly STATE_DIR="$HOME"/.local/share/gitpack
    fi

    readonly REPOS_DIR="$CACHE_DIR"/repos # cache for local repositories
    readonly FETCHED_PATH="$CACHE_DIR"/fetched # repositories fetch timestamps
    readonly STATUS_PATH="$STATE_DIR"/status # database of installed packages
}

#-------------------------------------------------------------------------------
# COMMAND PROCESSING
#-------------------------------------------------------------------------------

run_list() (
    db="$(get_db)" &&
    echon "$db" | while IFS= read -r db_record; do
        url="$(get_db_record_url "$db_record")" &&
        hash="$(get_db_record_hash "$db_record")" &&
        version="$(beautify_hash "$url" "$hash")" &&
        echo "$url $version" || return
    done
)

run_clean() {
    if ! remove_dir "$CACHE_DIR"; then
        echo 'E5: failed to remove cache directory' >&2; return 1
    fi
}

run_paths() {
    echo "cache-dir $CACHE_DIR" &&
    echo "state-dir $STATE_DIR"
}

# $@ - echo arguments
echon() {
    # no newline if empty string
    if [ "$@" ]; then
        echo "$@"
    fi
}

# $1 - minimal URL
# $2 - hash (optional)
beautify_hash() (
    if [ "$2" ]; then
        if ! [ "$hash_mode" ] && repo_cd "$1" 2>/dev/null &&
           ref="$(git describe --all --exact-match "$2" 2>/dev/null)"; then
            echo "${ref##*/}" # remove reference path prefix
        elif [ "$hash_mode" = long ]; then
            echo "$2" # return full hash
        else
            echo "$2" | cut -c 1-7 # return short hash
        fi
    fi
)

# $1 - directory path
remove_dir() {
    echod "removing directory $1" &&
    test "$1" && if ! [ -d "$1"/ ]; then return; fi &&

    # do not remove any important directory
    (   cd -- "$1"/ && real_path="$(pwd -P)" &&
        test "$PWD" != / && test "$real_path" != / &&
        test "$PWD" != // && test "$real_path" != // &&
        test "$PWD" != "$HOME" && test "$real_path" != "$HOME"
    ) &&

    rm -rf -- "${1:?}"/
}

# $1 - string
echod() {
    # print diagnostic message with defined prefix (progress reporting)
    echo "${DIAG_PREFIX}$1" >&2
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# $1 - action
# $2 - URL
perform_action() (
    echo "running $1 for $2" &&
    DIAG_PREFIX='  ' && # increase prefix indentation
    url="$(minimize_url "$2")" &&
    version="$(url_to_version "$2")" && # may be empty
    check_murl "$url" && # check minimal URL

    init_repo "$url" &&
    src_db_record="$(get_db_record "$url")" && # get package local information
    src_hash="$(get_db_record_hash "$src_db_record")" &&
    tar_hash="$(get_repo_hash "$url" "$version")" &&

    case "$1" in
        install) perform_install "$url" "$src_hash" "$tar_hash" ;;
        uninstall) perform_uninstall "$url" "$src_hash" ;;
        status) perform_status "$url" "$src_hash" "$tar_hash" ;;
    esac
)

# $1 - URL
minimize_url() (
    url="${1%%=*}" # remove version if any
    url="$(echo "$url" | tr '[:upper:]' '[:lower:]')" &&
    url="${url#https://}" &&
    echo "${url%.git}"
)

# $1 - URL
url_to_version() (
    version="${1#*=}" # remove URL and keep version
    if [ "$version" != "$1" ]; then
        echo "$version"
    fi
)

# $1 - minimal URL
check_murl() (
    lineno="$(echo "$1" | wc -l)" &&
    if [ "$lineno" -ne 1 ] || echo "$1" | grep -qE "$BAD_URL_REGEX"; then
        echo 'E6: unsupported URL delivered' >&2; return 1
    fi
)

#-------------------------------------------------------------------------------
# REPOSITORY
#-------------------------------------------------------------------------------

# $1 - minimal URL
init_repo() (
    if is_index_fresh "$1"; then
        echod 'local repository fresh'
    else
        repo_dir="$(url_to_path "$1")" &&
        fetch_repo "$1" "$repo_dir" &&
        update_index "$1" # mark as fresh
    fi
)

# $1 - minimal URL
# $2 - repository directory
fetch_repo() (
    if [ -d "$2"/ ]; then # repository already exists
        echod 'updating local repository' &&
        cd "$2"/
    else # create and configure repository
        echod 'downloading local repository' &&
        mkdir -p "$2"/ && cd "$2"/ &&
        # initialize Git repository manually
        git init -q &&
        git config gc.auto 0 && # disable garbage collector
        git config remote.origin.url https://"$1".git &&
        git config remote.origin.fetch "$HEAD_REFSPEC" &&
        git config --add remote.origin.fetch "$TAGS_REFSPEC" &&
        git config --add remote.origin.fetch "$HEADS_REFSPEC"
    fi &&
    # fetch remote updates (prune, do not fetch tags implicitly, update HEAD)
    git fetch -pnuq origin
)

# $1 - minimal URL
# $2 - version (optional)
get_repo_hash() (
    repo_cd "$1" &&
    if [ "$2" = HEAD ]; then # HEAD reference must point to remote HEAD
        set -- "$1" "$ORIGIN_HEAD"
    fi &&

    if [ "$2" ]; then
        echod 'using given candidate version' &&
        # print the commit hash of the version if it is a valid Git reference
        if ! git rev-parse -q --verify "$2"^0; then
            echo "E8: version $2 does not exist" >&2; return 1
        fi
    else # use latest tag (preferred) or latest commit of default branch
        echod 'using latest candidate version' &&
        ref="$(git describe --tags --abbrev=0 --always "$ORIGIN_HEAD")" &&
        git rev-parse --verify "$ref"^0 # get commit hash
    fi
)

# $1 - minimal URL
# $2 - hash (optional)
repo_cd() {
    cd "$(url_to_path "$1")"/ &&
    if [ "$2" ]; then
        git checkout -qf "$2"
    fi
}

# $1 - minimal URL
url_to_path() {
    echo "$REPOS_DIR"/"$1"
}

#-------------------------------------------------------------------------------
# EXECUTE ACTION
#-------------------------------------------------------------------------------

# $1 - minimal URL
# $2 - source hash (optional)
# $3 - target hash
perform_install() {
    if ! [ "$2" ]; then # not installed yet
        run_install "$1" "$3" &&
        insert_db_record "$1" "$3" &&
        echo 'done; successfully installed'
    elif [ "$2" = "$3" ]; then
        echo 'already installed'
    else
        perform_change "$1" "$2" "$3"
    fi
}

# $1 - minimal URL
# $2 - source hash
# $3 - target hash
perform_change() (
    if is_ancestor_commit "$1" "$2" "$3"; then # source version is older
        echod 'updating package' &&
        report='done; successfully updated'
    elif is_ancestor_commit "$1" "$3" "$2"; then # source version is newer
        echod 'downgrading package' &&
        report='done; successfully downgraded'
    else # given versions are not comparable
        echod 'changing package version' &&
        report='done; successfully changed'
    fi &&

    run_uninstall "$1" "$2" &&
    delete_db_records "$1" &&
    run_install "$1" "$3" &&
    insert_db_record "$1" "$3" &&
    echo "$report"
)

# $1 - minimal URL
# $2 - source hash (optional)
perform_uninstall() {
    if [ "$2" ]; then # if installed
        run_uninstall "$1" "$2" &&
        delete_db_records "$1" &&
        echo 'done; successfully uninstalled'
    else
        echo 'already uninstalled'
    fi
}

# $1 - minimal URL
# $2 - source hash (optional)
# $3 - target hash
perform_status() (
    src_version="$(beautify_hash "$1" "$2")" && # success even when empty
    tar_version="$(beautify_hash "$1" "$3")" &&

    if ! [ "$2" ]; then # no source version
        echo "not installed; candidate is $tar_version"
    elif [ "$2" = "$3" ]; then # given versions are equal
        echo "candidate $tar_version already installed"
    elif is_ancestor_commit "$1" "$2" "$3"; then # source version is older
        echo "installed $src_version is older than candidate $tar_version"
    elif is_ancestor_commit "$1" "$3" "$2"; then # source version is newer
        echo "installed $src_version is newer than candidate $tar_version"
    else # given versions are not comparable
        echo "installed $src_version differs from candidate $tar_version"
    fi
)

# $1 - minimal URL
# $2 - first hash
# $3 - second hash
is_ancestor_commit() (
    repo_cd "$1" &&
    git merge-base --is-ancestor "$2" "$3"
)

#-------------------------------------------------------------------------------
# INSTALLATION AND UNINSTALLATION
#-------------------------------------------------------------------------------

# $1 - minimal URL
# $2 - hash
run_install() (
    version="$(beautify_hash "$1" "$2")" &&
    echod "installing version $version" &&

    repo_cd "$1" "$2" &&
    install_script="$(get_install_script)" &&
    get_uninstall_script > /dev/null && # GitPack must be able to uninstall it
    run_script "$install_script"
)

# $1 - minimal URL
# $2 - hash
run_uninstall() (
    version="$(beautify_hash "$1" "$2")" &&
    echod "uninstalling version $version" &&

    repo_cd "$1" "$2" &&
    uninstall_script="$(get_uninstall_script)" &&
    run_script "$uninstall_script"
)

get_install_script() {
    if [ -x .install/install-"${ACCESS}-$SYSTEM" ]; then
        echo .install/install-"${ACCESS}-$SYSTEM"
    elif [ -x .install/install-"$ACCESS" ]; then
        echo .install/install-"$ACCESS"
    else
        echo 'E9: missing installation script' >&2; return 1
    fi
}

get_uninstall_script() {
    if [ -x .install/uninstall-"${ACCESS}-$SYSTEM" ]; then
        echo .install/uninstall-"${ACCESS}-$SYSTEM"
    elif [ -x .install/uninstall-"$ACCESS" ]; then
        echo .install/uninstall-"$ACCESS"
    else
        echo 'E10: missing uninstallation script' >&2; return 1
    fi
}

# $1 - script path
run_script() (
    echod "running script $1" &&
    DIAG_PREFIX='    ' &&
    "$1" 1>&2 && return # return if success, stdout considered diagnostic output

    script_status="$?"
    script_name="$(basename -- "$1")" &&
    echo "E11: $script_name script failed with $script_status" >&2
    return 1 # indicate error but do not propagate the exit status further
)

#-------------------------------------------------------------------------------
# PACKAGE DATABASE
#-------------------------------------------------------------------------------

init_db() {
    mkdir -p "$STATE_DIR"/ &&
    if ! [ -e "$STATUS_PATH" ]; then
        touch "$STATUS_PATH"
    fi &&

    if ! [ -r "$STATUS_PATH" ] || ! [ -w "$STATUS_PATH" ]; then
        echo 'E7: cannot access status file' >&2; return 1
    fi
}

# $1 - minimal URL
get_db_record() (
    echod 'reading package database' &&
    db="$(get_db)" &&
    records="$(echo "$db" | grepe -F -- "$1")" &&
    echo "$records" | head -n 1 # select only first match
)

# $1 - minimal URL
# $2 - hash
insert_db_record() {
    echod 'adding to package database' &&
    echo "$1 $2" >> "$STATUS_PATH"
}

# $1 - minimal URL
delete_db_records() (
    echod 'removing from package database' &&
    db="$(get_db)" &&
    records="$(echo "$db" | grepe -Fv -- "$1")" &&
    echon "$records" > "$STATUS_PATH"
)

get_db() {
    grepe . "$STATUS_PATH" # remove empty lines
}

# $@ - grep arguments
grepe() (
    grep "$@"
    grep_status="$?" # store grep exit status

    if [ "$grep_status" -eq 1 ]; then
        grep_status=0 # suppress empty selection indicator
    fi
    return "$grep_status"
)

# $1 - database record
get_db_record_url() {
    echo "${1%% *}" # remove hash
}

# $1 - database record
get_db_record_hash() {
    echo "${1#* }" # remove URL
}

#-------------------------------------------------------------------------------
# PACKAGE INDEX
#-------------------------------------------------------------------------------

init_index() {
    mkdir -p "$CACHE_DIR"/ &&
    if ! [ -e "$FETCHED_PATH" ]; then
        touch "$FETCHED_PATH"
    fi &&

    if ! [ -r "$FETCHED_PATH" ] || ! [ -w "$FETCHED_PATH" ]; then
        echo 'E12: cannot access fetched file' >&2; return 1
    fi
}

# $1 - minimal URL
is_index_fresh() (
    current_time="$(get_current_time)" &&

    index="$(get_index)" &&
    item="$(echo "$index" | grepe -F -- "$1")" &&
    item="$(echo "$item" | head -n 1)" && # just for sure
    item_time="$(get_index_item_time "$item")" &&

    test "$item_time" = "$current_time"
)

# $1 - minimal URL
update_index() (
    current_time="$(get_current_time)" &&

    index="$(get_index)" &&
    items="$(echo "$index" | grepe -Fv -- "$1")" && # remove item from the index

    # append item with updated time
    items="$(append_line "$items" "$1 $current_time")" &&
    echo "$items" > "$FETCHED_PATH"
)

get_current_time() {
    date -u '+%Y%m%d%H' # UTC as <year><month><day><hour>
}

get_index() {
    grepe . "$FETCHED_PATH" # remove empty lines
}

# $1 - index item
get_index_item_time() {
    echo "${1#* }" # remove URL
}

# $1 - original string
# $2 - appended string
append_line() {
    if [ "$1" ]; then
        echo "$1
$2"
    else # empty original string
        echo "$2" # do not print leading empty line
    fi
}

#-------------------------------------------------------------------------------
# CALL MAIN
#-------------------------------------------------------------------------------

main "$@"
