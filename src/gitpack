#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2019-2020 Dominik Salvet
# https://github.com/dominiksalvet/gitpack
#-------------------------------------------------------------------------------
# This is GitPack, a simple Git-based package manager. It is particularly useful
# for installing scripts across various platforms. This script is all you need
# to have GitPack running. All arguments are processed as GitPack help explains.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# MAIN FUNCTION
#-------------------------------------------------------------------------------

# $@ - GitPack arguments
main() {
    check_commands &&
    init_constants &&
    init_strings &&
    init_config &&
    process_args "$@"
}

check_commands() {
    if ! command -v git > /dev/null; then
        echo 'E1: missing git command' >&2; return 1
    fi
}

#-------------------------------------------------------------------------------
# STATIC INITIALIZATION
#-------------------------------------------------------------------------------

init_constants() {
    readonly VERSION=0.7.0 # current GitPack version
}

init_strings() {
    readonly HELP_MESSAGE='USAGE:
  gitpack ACTION URL[=VERSION]...
  gitpack COMMAND

ACTION:
  install    install/update package
  uninstall  uninstall package
  status     get package status

COMMAND:
  list   list installed packages
  clean  clean cache
  paths  show file paths
  help   show help
  about  show information'

    readonly ABOUT_MESSAGE="GitPack $VERSION
Simple Git-based package manager.

Copyright 2019-2020 Dominik Salvet
https://github.com/dominiksalvet/gitpack"
}

init_config() {
    readonly BAD_URL_REGEX='(^$| |(^|/)\.\.?($|/))' # ERE regex

    # mapping remote references to local ones
    readonly REMOTE_HEAD_REF=refs/HEAD
    readonly HEAD_REFSPEC=+HEAD:"$REMOTE_HEAD_REF"
    readonly TAGS_REFSPEC='+refs/tags/*:refs/tags/*'
    readonly HEADS_REFSPEC='+refs/heads/*:refs/heads/*' # branches
}

#-------------------------------------------------------------------------------
# ARGUMENT PROCESSING
#-------------------------------------------------------------------------------

# $@ - GitPack arguments
process_args() (
    case "$1" in
        install | uninstall | status)
            init_runtime && process_action_args "$@" ;;
        list | clean | paths)
            init_runtime && process_command_args "$@" ;;
        help) echo "$HELP_MESSAGE" ;;
        about) echo "$ABOUT_MESSAGE" ;;
        '') echo 'E2: no argument provided' >&2; return 1 ;;
        *) echo "E3: invalid argument $1" >&2; return 1 ;;
    esac
)

# $1 - action
# $@ - action arguments
process_action_args() (
    action="$1"
    shift && # shift to action arguments

    if [ "$#" -eq 0 ]; then
        echo 'E4: no URL provided' >&2; return 1
    fi &&

    for url in "$@"; do
        perform_action "$action" "$url" || return
    done
)

# $1 - command
# $@ - command arguments
process_command_args() (
    command="$1"
    shift && # shift to command arguments

    case "$command" in
        list) run_list ;;
        clean) run_clean ;;
        paths) run_paths ;;
    esac
)

#-------------------------------------------------------------------------------
# DYNAMIC INITIALIZATION
#-------------------------------------------------------------------------------

init_runtime() {
    init_runtime_constants &&
    init_paths &&
    init_db
}

init_runtime_constants() {
    _user_id="$(id -u)" &&
    if [ "$_user_id" -eq 0 ]; then
        readonly ACCESS=global
    else
        readonly ACCESS=local
    fi &&

    _system_name="$(uname)" &&
    readonly SYSTEM="$_system_name"
}

init_paths() {
    if [ "$ACCESS" = global ]; then # respect FHS
        readonly CACHE_DIR=/var/cache/gitpack
        readonly STATE_DIR=/var/lib/gitpack
    else # respect XDG
        readonly CACHE_DIR="$HOME"/.cache/gitpack
        readonly STATE_DIR="$HOME"/.local/share/gitpack
    fi

    readonly REPOS_DIR="$CACHE_DIR"/repos # cache for local repositories
    readonly STATUS_PATH="$STATE_DIR"/status # database of installed packages
}

#-------------------------------------------------------------------------------
# COMMAND PROCESSING
#-------------------------------------------------------------------------------

run_list() {
    echo todo
}

run_clean() {
    if ! remove_dir "$CACHE_DIR"; then
        echo 'E5: failed to remove cache directory' >&2; return 1
    fi
}

run_paths() {
    echo "cache-dir $CACHE_DIR" &&
    echo "state-dir $STATE_DIR"
}

# $1 - directory path
remove_dir() {
    test "$1" && if ! [ -d "$1"/ ]; then return; fi &&

    # do not remove any important directory
    (   cd -- "$1"/ && real_path="$(pwd -P)" &&
        test "$PWD" != / && test "$real_path" != / &&
        test "$PWD" != // && test "$real_path" != // &&
        test "$PWD" != "$HOME" && test "$real_path" != "$HOME"
    ) &&

    rm -rf -- "${1:?}"/
}

#-------------------------------------------------------------------------------
# ACTION PROCESSING
#-------------------------------------------------------------------------------

# $1 - action
# $2 - URL
perform_action() (
    url="$(minimize_url "$2")" &&
    version="$(url_to_version "$2")" &&
    check_murl "$url" &&
    init_repo "$url" &&

    echo todo
)

# $1 - URL
minimize_url() (
    url="${1%%=*}" # remove version if any
    url="$(echo "$url" | tr '[:upper:]' '[:lower:]')" &&
    url="${url#https://}" &&
    echo "${url%.git}"
)

# $1 - URL
url_to_version() (
    version="${1#*=}" # remove URL and keep version
    if [ "$version" != "$1" ]; then
        echo "$version"
    fi
)

# $1 - minimal URL
check_murl() (
    lineno="$(echo "$1" | wc -l)" &&
    if [ "$lineno" -ne 1 ] || echo "$1" | grep -qE "$BAD_URL_REGEX"; then
        echo 'E6: unsupported URL delivered' >&2; return 1
    fi
)

#-------------------------------------------------------------------------------
# REPOSITORY
#-------------------------------------------------------------------------------

# $1 - minimal URL
init_repo() (
    repo_dir="$(url_to_path "$1")" &&
    fetch_repo "$1" "$repo_dir"
)

# $1 - minimal URL
# $2 - repository directory
fetch_repo() (
    if [ -d "$2"/ ]; then # repository already exists
        cd "$2"/
    else # create and configure repository
        mkdir -p "$2"/ && cd "$2"/ &&
        # initialize Git repository manually
        git init -q &&
        git config gc.auto 0 && # disable garbage collector
        git config remote.origin.url https://"$1".git &&
        git config remote.origin.fetch "$HEAD_REFSPEC" &&
        git config --add remote.origin.fetch "$TAGS_REFSPEC" &&
        git config --add remote.origin.fetch "$HEADS_REFSPEC"
    fi &&
    # fetch remote updates (prune, do not fetch tags implicitly, update HEAD)
    git fetch -pnuq origin
)

# $1 - minimal URL
url_to_path() {
    echo "$REPOS_DIR"/"$1"
}

#-------------------------------------------------------------------------------
# DATABASE
#-------------------------------------------------------------------------------

init_db() {
    mkdir -p "$STATE_DIR"/ &&
    if [ ! -e "$STATUS_PATH" ]; then
        touch "$STATUS_PATH"
    fi &&

    if ! [ -r "$STATUS_PATH" ] || ! [ -w "$STATUS_PATH" ]; then
        echo 'E7: cannot access status file' >&2; return 1
    fi
}

#-------------------------------------------------------------------------------
# CALL MAIN
#-------------------------------------------------------------------------------

main "$@"
